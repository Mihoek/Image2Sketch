# -*- coding: utf-8 -*-
"""Untitled20.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-hfbZrLncRK2eQqhN4wVeCGJ-d2yDXDk
"""

# Installation des packages n√©cessaires
!pip install streamlit tensorflow opencv-python matplotlib pillow numpy pyngrok

# Importation des librairies pour les commandes Colab
import os
from pyngrok import ngrok

# Cr√©er un fichier mod√®le fictif pour le test si n√©cessaire
# (Vous devrez remplacer cela par votre vrai mod√®le plus tard)
!mkdir -p /content
!touch /content/image_to_sketch_model.h5

# Commented out IPython magic to ensure Python compatibility.
# # Cr√©ation du fichier app.py
# %%writefile app.py
# import streamlit as st
# import numpy as np
# import cv2
# from tensorflow.keras.models import load_model
# import matplotlib.pyplot as plt
# from PIL import Image
# import io
# import base64
# from datetime import datetime
# 
# # Configuration de la page
# st.set_page_config(
#     page_title="Transformateur d'Images en Croquis",
#     page_icon="‚úèÔ∏è",
#     layout="wide"
# )
# 
# # CSS pour am√©liorer l'apparence
# st.markdown('''
# <style>
#     .main-header {
#         font-size: 2.5rem;
#         color: #4A4A4A;
#         text-align: center;
#         margin-bottom: 2rem;
#     }
#     .sub-header {
#         font-size: 1.5rem;
#         color: #4A4A4A;
#         margin-bottom: 1rem;
#     }
#     .success-text {
#         color: #0ECB7E;
#         font-weight: bold;
#     }
#     .footer {
#         text-align: center;
#         margin-top: 2rem;
#         color: #6C757D;
#     }
#     .image-container {
#         display: flex;
#         justify-content: center;
#     }
#     .download-btn {
#         background-color: #4CAF50;
#         color: white;
#         padding: 0.5rem 1rem;
#         text-decoration: none;
#         border-radius: 4px;
#         display: inline-block;
#         margin-top: 1rem;
#     }
#     .download-btn:hover {
#         background-color: #45a049;
#     }
# </style>
# ''', unsafe_allow_html=True)
# 
# # Titre de l'application
# st.markdown("<h1 class='main-header'>Transformateur d'Images en Croquis</h1>", unsafe_allow_html=True)
# 
# # Chemin vers le mod√®le pr√©-entra√Æn√©
# MODEL_PATH = '/content/image_to_sketch_model.h5'
# 
# # Fonction pour charger le mod√®le
# @st.cache_resource
# def load_sketch_model(model_path):
#     try:
#         model = load_model(model_path)
#         st.success("‚úì Mod√®le charg√© avec succ√®s !")
#         return model
#     except Exception as e:
#         st.error(f"Erreur lors du chargement du mod√®le: {str(e)}")
#         st.info("Veuillez v√©rifier que le chemin du mod√®le est correct et que le fichier existe")
#         return None
# 
# # Charger le mod√®le automatiquement au d√©marrage
# model = load_sketch_model(MODEL_PATH)
# 
# # Preprocess image pour l'entr√©e du mod√®le
# def preprocess_image(img, target_size=(256, 256)):
#     # Convertir en RGB si n√©cessaire
#     if img.mode != 'RGB':
#         img = img.convert('RGB')
# 
#     # Redimensionner l'image
#     img = img.resize(target_size)
# 
#     # Convertir en numpy array et normaliser
#     img_array = np.array(img) / 255.0
# 
#     # Ajouter une dimension batch
#     return np.expand_dims(img_array, axis=0)
# 
# # G√©n√©rer un croquis √† partir de l'image
# def generate_sketch(model, img):
#     if model is None:
#         st.error("Aucun mod√®le valide n'est charg√©")
#         return None
# 
#     try:
#         preprocessed_img = preprocess_image(img)
#         sketch = model.predict(preprocessed_img)[0]
#         return sketch.reshape(sketch.shape[0], sketch.shape[1])
#     except Exception as e:
#         st.error(f"Erreur lors de la g√©n√©ration du croquis: {str(e)}")
#         return None
# 
# # Fonction pour appliquer des effets suppl√©mentaires
# def apply_effect(sketch, effect_type="normal"):
#     sketch_uint8 = (sketch * 255).astype(np.uint8)
# 
#     if effect_type == "high_contrast":
#         # Appliquer CLAHE pour un contraste adaptatif
#         clahe = cv2.createCLAHE(clipLimit=3.0, tileGridSize=(8, 8))
#         enhanced = clahe.apply(sketch_uint8)
#         return enhanced / 255.0
# 
#     elif effect_type == "soft":
#         # Appliquer un l√©ger flou pour des lignes plus douces
#         enhanced = cv2.GaussianBlur(sketch_uint8, (3, 3), 0)
#         return enhanced / 255.0
# 
#     elif effect_type == "sharp":
#         # Appliquer un filtre de nettet√©
#         kernel = np.array([[-1, -1, -1],
#                          [-1,  9, -1],
#                          [-1, -1, -1]])
#         enhanced = cv2.filter2D(sketch_uint8, -1, kernel)
#         return enhanced / 255.0
# 
#     else:
#         # Pas d'effet
#         return sketch
# 
# # Fonction pour obtenir un lien de t√©l√©chargement
# def get_image_download_link(img, filename, text):
#     buffered = io.BytesIO()
#     plt.figure(figsize=(10, 10))
#     plt.imshow(img, cmap='gray')
#     plt.axis('off')
#     plt.savefig(buffered, format="PNG", bbox_inches='tight', pad_inches=0, dpi=300)
#     plt.close()
#     buffered.seek(0)
#     img_str = base64.b64encode(buffered.getvalue()).decode()
#     href = f'<a href="data:file/png;base64,{img_str}" download="{filename}" class="download-btn">{text}</a>'
#     return href
# 
# # Cr√©er des onglets pour diff√©rentes m√©thodes d'entr√©e
# tab1, tab2 = st.tabs(["üìÅ T√©l√©charger une image", "üì∑ Utiliser la cam√©ra"])
# 
# with tab1:
#     st.markdown("<h2 class='sub-header'>T√©l√©chargez votre image</h2>", unsafe_allow_html=True)
#     uploaded_file = st.file_uploader("Choisissez une image...", type=["jpg", "jpeg", "png"], key="file_uploader")
# 
#     if uploaded_file is not None:
#         # Obtenir l'image
#         image = Image.open(uploaded_file).convert('RGB')
# 
#         # Afficher l'image originale
#         st.image(image, caption='Image t√©l√©charg√©e', use_column_width=True)
# 
#         # Stocker l'image dans l'√©tat de session pour le traitement
#         st.session_state.current_image = image
# 
# with tab2:
#     st.markdown("<h2 class='sub-header'>Prenez une photo</h2>", unsafe_allow_html=True)
#     img_file_buffer = st.camera_input("Prenez une photo", key="camera_input")
# 
#     if img_file_buffer is not None:
#         # Obtenir l'image
#         image = Image.open(img_file_buffer).convert('RGB')
# 
#         # Stocker l'image dans l'√©tat de session pour le traitement
#         st.session_state.current_image = image
# 
# # Section de traitement - appara√Æt si nous avons une image et un mod√®le valide
# if 'current_image' in st.session_state and model is not None:
#     st.markdown("<h2 class='sub-header'>G√©n√©rer le croquis</h2>", unsafe_allow_html=True)
# 
#     # S√©lection d'effet
#     effect_options = {
#         "normal": "Normal",
#         "high_contrast": "Contraste √©lev√©",
#         "soft": "Adouci",
#         "sharp": "Net"
#     }
#     selected_effect = st.selectbox(
#         "Choisissez un effet pour votre croquis",
#         list(effect_options.keys()),
#         format_func=lambda x: effect_options[x]
#     )
# 
#     # Bouton de g√©n√©ration
#     if st.button('G√©n√©rer le croquis'):
#         with st.spinner('G√©n√©ration du croquis en cours...'):
#             # G√©n√©rer le croquis
#             sketch = generate_sketch(model, st.session_state.current_image)
# 
#             if sketch is not None:
#                 # Appliquer l'effet s√©lectionn√©
#                 enhanced_sketch = apply_effect(sketch, selected_effect)
# 
#                 # Afficher les r√©sultats
#                 col1, col2 = st.columns(2)
#                 with col1:
#                     st.image(st.session_state.current_image, caption="Image originale")
#                 with col2:
#                     st.image(enhanced_sketch, caption=f"Croquis ({effect_options[selected_effect]})",
#                             use_column_width=True, clamp=True)
# 
#                 # Stocker pour le t√©l√©chargement
#                 st.session_state.current_sketch = enhanced_sketch
#             else:
#                 st.error("Erreur lors de la g√©n√©ration du croquis")
# 
# # Section de t√©l√©chargement
# if 'current_sketch' in st.session_state:
#     st.markdown("<h2 class='sub-header'>T√©l√©charger le r√©sultat</h2>", unsafe_allow_html=True)
#     timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
#     filename = f"sketch_{timestamp}.png"
# 
#     st.markdown(
#         get_image_download_link(
#             st.session_state.current_sketch,
#             filename,
#             "‚¨áÔ∏è T√©l√©charger le croquis"
#         ),
#         unsafe_allow_html=True
#     )
# 
# # Section √Ä propos
# with st.expander("‚ÑπÔ∏è √Ä propos de cette application"):
#     st.markdown('''
#     ### Comment √ßa marche ?
#     Cette application utilise un mod√®le de deep learning (U-Net) situ√© √† `/content/image_to_sketch_model.h5` pour transformer vos images en croquis.
# 
#     ### Conseils :
#     - Les images avec bon contraste fonctionnent mieux
#     - Essayez diff√©rents effets pour des r√©sultats vari√©s
#     - Pour les portraits, l'effet "Adouci" donne souvent de bons r√©sultats
# 
#     ### Technologies utilis√©es :
#     - TensorFlow/Keras pour le mod√®le
#     - Streamlit pour l'interface
#     - OpenCV pour le traitement d'image
#     ''')
# 
# # Pied de page
# st.markdown("<div class='footer'>¬© 2023 Image-to-Sketch Transformer</div>", unsafe_allow_html=True)
# 
# # COMMANDES D'EX√âCUTION √Ä LANCER S√âPAR√âMENT (NE PAS INCLURE DANS app.py)
# # Ces commandes doivent √™tre ex√©cut√©es dans une cellule Colab s√©par√©e
# 
# # Cr√©ation d'une nouvelle cellule avec ce code pour lancer l'application:
# # !wget -q -O - ipv4.icanhazip.com
# # !streamlit run app.py & npx localtunnel --port 8501

# Obtenir l'adresse IP publique
!wget -q -O - ipv4.icanhazip.com

# D√©marrer l'application Streamlit et exposer avec localtunnel
!streamlit run app.py & npx localtunnel --port 8501